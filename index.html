<html>
    <head>
        <title>Masked Categorisation Task</title>
    	<meta charset="utf-8"/>
        <!-- pull in jsPsych resources -->
        <script src="jspsych-6.3.1/jspsych.js"></script>
        <script src="jspsych-6.3.1/plugins/jspsych-image-button-response.js"></script>
        <script src="jspsych-6.3.1/plugins/jspsych-html-button-response.js"></script>
        <script src="jspsych-6.3.1/plugins/jspsych-html-keyboard-response.js"></script>
        <!-- pull in experiment resources -->
        <script src="lib/consent.js"></script>
        <script src="lib/demographics.js"></script>
        <!-- some additional styling to make the background black -->
        <link href="lib/exp.css" rel="stylesheet" type="text/css"></link>
        <style></style>
    </head>
    <body></body>
    <script>

        console.log("starting experiment");

        ///////////////////
        /* set up params */
        ///////////////////

        var fixation_time = 200; // ms to display fixation

        var stimulus_difficulty = {
            valid: [1,2,3,4,5], // valid stimulus difficulties, should correspond to folder names
            default: 3, // default stim difficulty (used for first trials to establish accuracy)
            min: 1, // min stimulus difficulty (to limit titration from going too far down)
            max: 5, // max stimulus difficulty (to limit titration from going too far up)
            method: 'specified', // determined by 'accuracy' or 'specified'
            accuracy: 50, // if accuracy, percentage difficulty to titrate to
            history: 4, // if accuracy, number of trials to check accuracy over
            repetitions: 10, // if specified, number of times to present each stimulus difficulty per image type
            order: [] // generate this later
        };

        // array of stimulus difficulties valid*repetitions
        for (reps = 0; reps < stimulus_difficulty.repetitions; reps++) {
            stimulus_difficulty.order = stimulus_difficulty.order.concat(stimulus_difficulty.valid);
        }
        // we'll probably want to counterbalance these
        
        function stimulusPathFactory(label, variant, difficulty, whichPath){
            var stim_path = `stimuli/masked_datasets/${label}/${difficulty}/${variant}.jpg`;
            var prompt_path = `stimuli/unmasked_datasets/${label}.jpg`;
            if (whichPath === 'stimulus') {
                return stim_path;
            } else if (whichPath === 'prompt') {
                return prompt_path;
            }
        }

        var stimuli = {
            labels: [ // these should match stimuli and response prompt names sans extension
                'car',
                'elephant',
                'fish',
                'hammer',
                'hand_blower',
                'hat',
                'iron',
                'ladybug',
                'pineapple',
                'pot',
                'sewing_machine',
                'violin',
            ],
            quantity: 100, // quantity of variants of each image type
            order: [], // we'll generate this later
            variant_order: [], // generate later
            stimuli_paths: [], // generate this later
            prompt_order: [], // generate this later
            prompt_html_array: [] // generate this later
        };

        for (i=0; i < stimuli.labels.length; i++) {
        // array of indices for response prompt order
            stimuli.prompt_order = stimuli.prompt_order.concat(i);
            stimuli.prompt_html_array = stimuli.prompt_html_array.concat('<img src="' + stimulusPathFactory(stimuli.labels[i],null,null,'prompt') + '" />');
            for (rep = 0; rep < stimuli.quantity; rep++) {
                // array of indices for stimuli.labels*quantity
                stimuli.order = stimuli.order.concat(i);
                stimuli.variant_order = stimuli.variant_order.concat(rep+1); // plus one because js starts at 0
                for (diff = 0; diff < stimulus_difficulty.valid.length; diff++) {
                    diffMod = diff+1; // add one because js starts at 0
                    repMod = rep+1; // add one because js starts at 0
                    stimuli.stimuli_paths = stimuli.stimuli_paths.concat(stimulusPathFactory(stimuli.labels[i],repMod.toString(),diffMod.toString(),'stimulus'));
                }
            }
        }
        // we'll probably want to counterbalance these

        /* initialise timeline array */

        var timeline = [];

        //////////////////////////
        /* set up a basic trial */
        //////////////////////////

        var fixation = {
            type: 'html-keyboard-response',
            stimulus: '<p style="font-size: 48px;">+</p>',
            choices: jsPsych.NO_KEYS,
            trial_duration: fixation_time,
            data: {experiment_part: 'fixation'}
        };

        var basic_trial = {
            type: 'image-button-response',
            // stimulus: 'img/stimulus', // we'll specify this dynamically
            choices: stimuli.prompt_html_array,
            // choices: [
            //     '<img src="img/response-one.png" />',
            //     '<img src="img/response-two.png" />'
            // ],
            //button_html: ['<button class="jspsych-btn">%choice%</button>'],
            prompt: "<p>Select Response</p>",
            data: {experiment_part: 'trial'}
        };

        function difficultyTitration(thisStimDiff) {
            console.log('titrate difficulty');
            console.log('from difficulty: ',thisStimDiff);

                // filter to trials, then count correct trials
                var last_correct = jsPsych.data.get().filter({
                    experiment_part: 'trial'
                }).last(stimulus_difficulty.history).filter({correct: true}).count();

                // update stimulus difficulty based on desired accuracy
                var last_accuracy = (last_correct/stimulus_difficulty.history)*100;
            console.log('last accuracy was: ',last_accuracy);
                if (last_accuracy < stimulus_difficulty.accuracy) {
                    var newStimDiff = thisStimDiff+1;
                } else if (last_accuracy > stimulus_difficulty.accuracy) {
                    var newStimDiff = thisStimDiff-1;
                } else if (last_accuracy == stimulus_difficulty.accuracy) {
                    var newStimDiff = thisStimDiff;
                }

                // limit stimulus difficulty to min/max
                if (newStimDiff < stimulus_difficulty.min) {
                    newStimDiff = stimulus_difficulty.min;
                } else if (newStimDiff > stimulus_difficulty.max) {
                    newStimDiff = stimulus_difficulty.max;
                }
            console.log('new difficulty: ',newStimDiff);

                return newStimDiff;
        }
        
        function getStimulus(trial_number, stimDifficulty) {
            // put together the stimulus path based on the trial, the array of timuli, and the difficulty
                    return stimulusPathFactory(stimuli.labels[stimuli.order[trial_number]],stimuli.variant_order[trial_number].toString(),stimDifficulty.toString(),'stimulus');

        }

        ////////////////////////
        /* experiment testing */
        ////////////////////////

        var thisDifficulty = stimulus_difficulty.default; // declare this as global variable

        for (trial = 0; trial < 7; trial++) {
            if (stimulus_difficulty.method === 'accuracy' && trial < stimulus_difficulty.history) {
                // add enough trials to start checking history for accuracy
                timeline.push(
                    {...fixation,
                        data: {...fixation.data,
                            trial_num: trial
                        }
                    },
                    {...basic_trial,
                         stimulus: function() {
                            console.log('using default difficulty to establish baseline');
                            return getStimulus(
                                jsPsych.data.get().last(1).values()[0].trial_num,
                                stimulus_difficulty.default
                            );
                         },
                        on_finish: function(data) {
                            // code for correctness
                            var response = jsPsych.data.get().last(1).values()[0].response;
                            var stimulus_index = jsPsych.data.get().last(2).values()[0].trial_num;
                            if (stimuli.prompt_order[response] == stimuli.order[stimulus_index]) {
                                console.log('correct')
                                data.correct = true;
                            } else {
                                console.log('incorrect')
                                data.correct = false;
                            }
                            data.response_label = stimuli.labels[stimuli.prompt_order[stimulus_index]]
                            data.stimulus_label = stimuli.labels[stimuli.order[stimulus_index]]
                            data.stimulus_variant = stimuli.variant_order[stimulus_index]
                        }
                    }
                );
            } else {
                timeline.push(
                    {...fixation,
                        data: {...fixation.data,
                            trial_num: trial
                        }
                    },
                    {...basic_trial,
                        stimulus: function() {
                            return getStimulus(
                                jsPsych.data.get().last(1).values()[0].trial_num, // use the index we specified in fixation
                                thisDifficulty
                            );
                        },
                        on_finish: function(data) {
                            // code for correctness
                            var response = jsPsych.data.get().last(1).values()[0].response;
                            var stimulus_index = jsPsych.data.get().last(2).values()[0].trial_num;
                            if (stimuli.prompt_order[response] == stimuli.order[stimulus_index]) {
                                console.log('correct')
                                data.correct = true;
                            } else {
                                console.log('incorrect')
                                data.correct = false;
                            }
                            data.response_label = stimuli.labels[stimuli.prompt_order[stimulus_index]]
                            data.stimulus_label = stimuli.labels[stimuli.order[stimulus_index]]
                            data.stimulus_variant = stimuli.variant_order[stimulus_index]

                            // adjust difficulty
                            if (stimulus_difficulty.method === 'accuracy') {
                                thisDifficulty = difficultyTitration(thisDifficulty);
                            } else if (stimulus_difficulty.method === 'specified') {
                                thisDifficulty = stimulus_difficulty.order[stimulus_index];
                                console.log('next difficulty will be: ', thisDifficulty);
                            }
                        }
                    }
                );
            }
        }
    
        jsPsych.init({
            timeline: timeline,
            //preload_images: ,
            on_finish: function() {
                jsPsych.data.displayData();
                var time = jsPsych.totalTime();
                jsPsych.data.addProperties({
                    expt_duration: time,
                });
            }
        });

    </script>
</html>
